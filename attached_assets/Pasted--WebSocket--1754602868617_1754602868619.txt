âš™ï¸ ĞÑ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€Ğ°
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ WebSocket  â”‚â—„â”€â”€â”€â”€â”€â–º Ğ ĞµĞ°Ğ»ÑŒĞ½Ğ¾Ğµ Ğ²Ñ€ĞµĞ¼Ñ: ÑÑ‚Ğ°ĞºĞ°Ğ½, ÑĞ´ĞµĞ»ĞºĞ¸
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚
     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ClusterEngineâ”‚â—„â”€â”€â”€â”€â”€â–º ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° ÑĞ²ĞµÑ‡ĞµĞ¹, ĞºĞ»Ğ°ÑÑ‚ĞµÑ€Ğ¾Ğ², Ğ¾Ğ±ÑŠÑ‘Ğ¼Ğ¾Ğ²
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚
     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Redis Cacheâ”‚â—„â”€â”€â”€â”€â”€â–º Ğ‘Ñ‹ÑÑ‚Ñ€Ñ‹Ğ¹ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿ Ğº ĞºĞ»Ğ°ÑÑ‚ĞµÑ€Ğ°Ğ¼, ÑÑ‚Ğ°ĞºĞ°Ğ½Ñƒ
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚
     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ PostgreSQL â”‚â—„â”€â”€â”€â”€â”€â–º Ğ˜ÑÑ‚Ğ¾Ñ€Ğ¸Ñ‡ĞµÑĞºĞ¸Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ, ÑĞ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
ğŸ“¦ ĞœĞ¾Ğ´ÑƒĞ»Ğ¸
1. cluster_updater.py
ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµÑ‚ ĞºĞ»Ğ°ÑÑ‚ĞµÑ€Ñ‹ Ğ¿Ğ¾ Ñ€Ğ°ÑĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ñ

ĞŸĞ¾Ğ´Ğ´ĞµÑ€Ğ¶Ğ¸Ğ²Ğ°ĞµÑ‚ Ğ¿Ğ°ÑÑĞ¸Ğ²Ğ½Ñ‹Ğ¹ Ñ€ĞµĞ¶Ğ¸Ğ¼ (Ğ±ĞµĞ· Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ… Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹)

Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµÑ‚ asyncio + aiohttp

python
async def update_clusters(symbol, tf):
    trades = await fetch_trades(symbol)
    clusters = aggregate_clusters(trades)
    await redis.set(f"clusters:{symbol}:{tf}", clusters)
    await postgres.insert(clusters)
2. depth_filter.py
Ğ¤Ğ¸Ğ»ÑŒÑ‚Ñ€ÑƒĞµÑ‚ ÑÑ‚Ğ°ĞºĞ°Ğ½ Ğ¿Ğ¾ Ğ´Ğ¸Ğ½Ğ°Ğ¼Ğ¸Ñ‡ĞµÑĞºĞ¾Ğ¹ Ğ³Ğ»ÑƒĞ±Ğ¸Ğ½Ğµ

Ğ£Ñ‡Ğ¸Ñ‚Ñ‹Ğ²Ğ°ĞµÑ‚ Ñ‚ĞµĞºÑƒÑ‰ÑƒÑ Ñ†ĞµĞ½Ñƒ Ğ¸ Ğ¼Ğ°ÑÑˆÑ‚Ğ°Ğ±

python
def filter_depth(depth, center_price, range_percent):
    min_p = center_price * (1 - range_percent / 100)
    max_p = center_price * (1 + range_percent / 100)
    return [d for d in depth if min_p <= d['price'] <= max_p]
3. sync_manager.py
ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµÑ‚ Ğ½ĞµĞ´Ğ¾ÑÑ‚Ğ°ÑÑ‰Ğ¸Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ¿Ñ€Ğ¸ Ğ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğ¸

Ğ—Ğ°Ğ³Ñ€ÑƒĞ¶Ğ°ĞµÑ‚ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ¾Ñ‚ÑÑƒÑ‚ÑÑ‚Ğ²ÑƒÑÑ‰Ğ¸Ğµ ÑĞ²ĞµÑ‡Ğ¸/ĞºĞ»Ğ°ÑÑ‚ĞµÑ€Ñ‹

python
def sync_on_connect(symbol, tf, from_ts, to_ts):
    missing = check_missing(symbol, tf, from_ts, to_ts)
    for r in missing:
        candles = fetch_candles(symbol, tf, r.start, r.end)
        clusters = aggregate_clusters(candles)
        redis.set(...)
        postgres.insert(...)
4. redis_interface.py
ĞĞ±Ñ‘Ñ€Ñ‚ĞºĞ° Ğ½Ğ°Ğ´ Redis

TTL, ĞºĞ»ÑÑ‡Ğ¸, ÑĞµÑ€Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ

python
def set_cluster(symbol, tf, ts, data):
    key = f"clusters:{symbol}:{tf}:{ts}"
    redis.set(key, json.dumps(data), ex=60)
5. postgres_model.py
ORM-Ğ¼Ğ¾Ğ´ĞµĞ»ÑŒ Ğ´Ğ»Ñ Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ñ ĞºĞ»Ğ°ÑÑ‚ĞµÑ€Ğ¾Ğ², ÑĞ²ĞµÑ‡ĞµĞ¹, ÑÑ‚Ğ°ĞºĞ°Ğ½Ğ°

python
class Cluster(Base):
    __tablename__ = 'clusters'
    symbol = Column(String)
    tf = Column(String)
    ts = Column(DateTime)
    volume = Column(Float)
    delta = Column(Float)
    price_range = Column(JSON)
ğŸ§  ĞĞ»Ğ³Ğ¾Ñ€Ğ¸Ñ‚Ğ¼Ñ‹
ğŸ”„ Smart Refresh
ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ¿Ñ€Ğ¸ Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ğ¸ Ñ†ĞµĞ½Ñ‹ > threshold

Ğ¡Ğ½Ğ¸Ğ¶ĞµĞ½Ğ¸Ğµ Ğ½Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ¸

ğŸ”® Predictive Preload
ĞŸÑ€ĞµĞ´Ğ·Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ° Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… Ğ¿Ñ€Ğ¸ ÑĞºÑ€Ğ¾Ğ»Ğ»Ğµ

Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµÑ‚ÑÑ Ğ½Ğ° Ñ„Ñ€Ğ¾Ğ½Ñ‚Ğµ

ğŸ“Š Adaptive Cluster Size
Ğ¨Ğ°Ğ³ ĞºĞ»Ğ°ÑÑ‚ĞµÑ€Ğ¾Ğ² Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ñ‚ Ğ¾Ñ‚ ATR

Ğ“Ğ¸Ğ±ĞºĞ°Ñ Ğ°Ğ³Ñ€ĞµĞ³Ğ°Ñ†Ğ¸Ñ

ğŸ§ª Ğ¢ĞµÑÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ
pytest + async fixtures

ĞœĞ¾ĞºĞ¸ Ğ´Ğ»Ñ WebSocket, Redis, PostgreSQL

ĞĞ°Ğ³Ñ€ÑƒĞ·Ğ¾Ñ‡Ğ½Ğ¾Ğµ Ñ‚ĞµÑÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ: locust

ğŸ“ˆ Ğ¤Ñ€Ğ¾Ğ½Ñ‚ĞµĞ½Ğ´ (Ğ¾Ğ¿Ñ†Ğ¸Ğ¾Ğ½Ğ°Ğ»ÑŒĞ½Ğ¾)
WebSocket ĞºĞ»Ğ¸ĞµĞ½Ñ‚

Ğ“Ñ€Ğ°Ñ„Ğ¸Ğº Ğ½Ğ° lightweight-charts

ĞšĞ»Ğ°ÑÑ‚ĞµÑ€Ñ‹, ÑÑ‚Ğ°ĞºĞ°Ğ½, Ğ¾Ğ±ÑŠÑ‘Ğ¼Ñ‹

ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ¸ Ğ³Ğ»ÑƒĞ±Ğ¸Ğ½Ñ‹, Ñ‚Ğ°Ğ¹Ğ¼Ñ„Ñ€ĞµĞ¹Ğ¼Ğ°, Ğ°Ğ³Ñ€ĞµÑÑĞ¸Ğ¸

ğŸš€ Ğ Ğ°Ğ·Ğ²Ñ‘Ñ€Ñ‚Ñ‹Ğ²Ğ°Ğ½Ğ¸Ğµ
Docker + Docker Compose

Redis, PostgreSQL, FastAPI

supervisord Ğ´Ğ»Ñ Ñ„Ğ¾Ğ½Ğ¾Ğ²Ñ‹Ñ… Ğ·Ğ°Ğ´Ğ°Ñ‡

yaml
services:
  redis:
    image: redis
  postgres:
    image: postgres
  backend:
    build: .
    command: supervisord -c supervisord.conf
ğŸ§© Ğ Ğ°ÑÑˆĞ¸Ñ€ĞµĞ½Ğ¸Ñ
ĞŸĞ¾Ğ´Ğ´ĞµÑ€Ğ¶ĞºĞ° Ğ½ĞµÑĞºĞ¾Ğ»ÑŒĞºĞ¸Ñ… Ğ±Ğ¸Ñ€Ğ¶

AI-Ğ°Ğ½Ğ°Ğ»Ğ¸Ğ· ÑĞ²ĞµÑ‡ĞµĞ¹

ĞĞ»Ğ³Ğ¾Ñ€Ğ¸Ñ‚Ğ¼Ğ¸Ñ‡ĞµÑĞºĞ¸Ğµ ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ñ‹

Ğ˜ÑÑ‚Ğ¾Ñ€Ğ¸Ñ‡ĞµÑĞºĞ¸Ğ¹ Ñ€ĞµĞ¶Ğ¸Ğ¼